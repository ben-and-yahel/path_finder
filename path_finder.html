
<html lang="en">
<head>
    <style>
        html, body {
        width:  100%;
        height: 100%;
        margin: 0;
                }       
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path finder</title>
</head>
<body>
    
<!-- TODO: make an down list for algorithems -->
<div>
<h1 style="user-select: none;color: white; background-color:purple;font-family: Comic Sans MS;">
    Welocome to the Path Finder!</h1>
</div>
    <canvas id="gc" onclick="onClick(event);"></canvas>
    
    <script>
    window.onload =function() {
    document.addEventListener("keypress",draw_path);
    //document.addEventListener("click", onClick);
    document.oncontextmenu = onClick;
    canv=document.getElementById("gc");
    ctx = canv.getContext("2d");
    ctx.canvas.width  = window.innerWidth- 10;
    ctx.canvas.height = window.innerHeight - strap_height;
    init();
    
}

class Point{
    constructor(x, y, color){
        this.x = x;
        this.y = y;
        this.color = color;
        this.H_cost = 0;
        this.G_cost = 0;
        this.F_cost = 0;
    }
    upgrade() {
        this.H_cost = calculateHcost(this);
        this.G_cost = calculateGcost(this);
        this.F_cost = this.H_cost + this.G_cost;
    }
}
class Node{
    constructor(p,n){
        this.point = p;
        this.node = n;
    }
    upgrade() {
        this.point.upgrade();
    }

}
strap_height = 100;
height = width = 100;
seperate = 10;
squars = []; // square => [color]
startExist = false;
start = end = Object;
function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}

function distance(A,B)
{
    return Math.floor(Math.sqrt((Math.pow(A.x-B.x,2)+Math.pow(A.y-B.y,2))))*10;
}
function calculateGcost(P)
{
    return distance(P,start)
}
function calculateHcost(P)
{
    return distance(P,end)
}
function beenThere1D(p,pArray)
{
    var x = 0;
    pArray.forEach(point => {
            if(point.x == p.x && point.y == p.y)
                return x;
            x++
    });
    return -1;
}
function beenThere2D(p,pArray)
{
    var x = 0;
    var y = 0;
    pArray.forEach(point => {
        pArray.forEach(inPoint =>{
            if(inPoint.x == p.x && inPoint.y == p.y)
                return new Point(x,y);
            y++;
        });
        x++;
    });
    return new Point(-1,-1);
}
function haventBeenThere(x,y,ExpendedNode)
{
    let curr = ExpendedNode;
    while (curr)
    {
        if(curr.point.x == x && curr.point.y == y)
            return false;
        curr = curr.node;
    }

    return true;
}
function ExpandArray(ExpendedNode)
{
    let NodesArray = [];
    let width = squars.length;
    let height = squars[0].length;
    let x = ExpendedNode.point.x;
    let y = ExpendedNode.point.y;
    if(x-1 >= 0 && squars[x-1][y] != "black" && haventBeenThere(x-1,y,ExpendedNode))
        NodesArray.push(new Node(new Point(x-1,y,"green"),ExpendedNode));
    if(x+1 < width && squars[x+1][y] != "black" && haventBeenThere(x+1,y,ExpendedNode))
        NodesArray.push(new Node(new Point(x+1,y,"green"),ExpendedNode));
    if(y-1 >= 0 && squars[x][y-1] != "black" && haventBeenThere(x,y-1,ExpendedNode))
        NodesArray.push(new Node(new Point(x,y-1,"green"),ExpendedNode));
    if(y+1 < height && squars[x][y+1] != "black" && haventBeenThere(x,y+1,ExpendedNode))
        NodesArray.push(new Node(new Point(x,y+1,"green"),ExpendedNode));
    for (let index = 0; index < NodesArray.length; index++) 
        NodesArray[index].upgrade();
        
    return NodesArray;
}
function sortByFcost(nodeArray)
{
    for (let X = 0; X < nodeArray.length; X++) {
        for (let Y = 0; Y < nodeArray.length - 1; Y++) {
            if(nodeArray[Y].point.F_cost > nodeArray[Y + 1].point.F_cost)
            {
                let temp = nodeArray[Y + 1];
                nodeArray[Y + 1] = nodeArray[Y];
                nodeArray[Y] = temp;
            }
            else if((nodeArray[Y].point.F_cost == nodeArray[Y + 1].point.F_cost) && (nodeArray[Y].point.H_cost < nodeArray[Y + 1].point.H_cost))
            {
                let temp = nodeArray[Y + 1];
                nodeArray[Y + 1] = nodeArray[Y];
                nodeArray[Y] = temp;
            }
        }
    }
    let f = nodeArray[0].point.F_cost;
    for (let X = 0; X < nodeArray.length; X++) {
        for (let Y = 0; Y < nodeArray.length - 1; Y++) {
            if((nodeArray[Y].point.F_cost == f) && (nodeArray[Y].point.H_cost > nodeArray[Y + 1].point.H_cost))
            {
                let temp = nodeArray[Y + 1];
                nodeArray[Y + 1] = nodeArray[Y];
                nodeArray[Y] = temp;
            }
            
        }
    }
    return nodeArray;
}
function A_algorithem()
{
    let startNode = new Node(start,null);
    let NodesArray = ExpandArray(startNode);
    let bestTrace = null;
    var exit = true;
    while(exit)
    {
        if(NodesArray.length == 0){
        exit = false;
        continue;
    }
        NodesArray = sortByFcost(NodesArray);
        tempNodeArray = ExpandArray(NodesArray[0]);
        console.log(NodesArray.splice(0,1));
        NodesArray.push.apply(NodesArray,tempNodeArray);
        NodesArray.forEach(n => {
            squars[n.point.x][n.point.y] = "pink"
            if(n.point.x == end.x && n.point.y == end.y){
                bestTrace = n; 
                exit = false;
            }
        });
        printSquares();
    }
    return bestTrace;
}
function draw_path(e) {
    //e.keyCode
    
    // switch (algorithem)
    // {
    //     case 1:
    //         function
    //         break;
    // }

    let result = A_algorithem();
    //i = row
    //j = line
    //the if is the core. for changing to line enter j ext...
    //alert(start + " "+end);
    if(result == null)
        return;
    result = result.node;
    squars[end.x][end.y] = "red";
    while(result.node)
    {
        squars[result.point.x][result.point.y] = "#00ffcc";  
        result = result.node;
    }
    /*for (let i = start.x+1; i < end.x; i++) {
        squars[i][start.y] = "#00ffcc";      
    }*/
    // for (let i = 0; i < squars.length; i++) {
    //     for (let j = 0; j < squars[i].length; j++) {
    //         if (i == 2) {
    //             squars[i][j][2] = "#00ffcc";
    //         }
    //     }
    // }

    printSquares();
}
function onClick(e) {
    pageShift = 65;
    clicX = e.pageX;
    clicY = e.pageY-pageShift;
    //alert(clicX+" "+clicY);
    isChanged = false;
    for (let x = 0; x < squars.length; x++) {
        for (let y = 0; y < squars[x].length; y++) {
            if (e.button==2 && (squars[x][y] == "blue" || squars[x][y] == "red")) {
                if (squars[x][y] == "blue" && !startExist) {
                    squars[x][y] = "grey";
                }
                else if (squars[x][y] == "red" && startExist) {
                    squars[x][y] = "grey";
                }
                printSquares();
            }
            if (clicX >= x*width && clicX <= x*width+width-seperate 
                && clicY >= y*height && clicY <= y*height+height-seperate) {
                    //alert(1);
                    if (e.button == 2) {
                        //if there is start so it gone to red for end
                        if (startExist) {
                            squars[x][y] =  "red";
                            end = new Point(x, y);
                        }
                        else
                        {
                            squars[x][y] = "blue"; 
                            start = new Point(x, y);
                        }
                        isChanged = true;// if endpoint is set we update it in the end of the func
                    }
                    else if (squars[x][y] != "grey") {
                        squars[x][y] = "grey";
                    }
                    else{
                        squars[x][y] = "black";
                    }
                    printSquares();
            }        
            //ctx.fillRect(i*width, j*height, width-seperate, height-seperate);
        }
    }
    isChanged ? startExist = !startExist : false;
    isChanged = false;
    return false;
}
function init() {
    //makes the squars
    for (let i = 0; i < ctx.canvas.width/width; i++) {
        tmp_squars_line = [];
        for (let j = 0; j < ctx.canvas.height/height; j++) {
            //ctx.fillRect(i+seperate, j+seperate, width, height);
            tmp_squars_line.push(["grey"]); // i,j is location | false is for isBarriar     
        } 
        squars.push(tmp_squars_line);       
    }
    printSquares(squars);
}
function printSquares() {
    x = y = 0;
    color = "grey";
    for (let i = 0; i < squars.length; i++) {
        for (let j = 0; j < squars[i].length; j++) {
            color = squars[i][j];
            ctx.fillStyle = color;
            ctx.fillRect(i*width, j*height, width-seperate, height-seperate);
        }
    }
}
    </script>
</body>
</html>